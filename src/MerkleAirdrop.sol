// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Context} from "@openzeppelin/contracts/utils/Context.sol";
import {BitmapState} from "./abstract/BitmapState.sol";
import {IAirdropVault} from "./interfaces/IAirdropVault.sol";

/**
 * @title MerkleAirdrop
 * @author BinnaDev (Obinna Franklin Duru)
 * @notice Core M1 contract for static, indexed airdrops.
 * Verifies Merkle proofs against an immutable root and uses BitmapState for
 * gas-efficient, replay-protected claims.
 *
 * @dev This contract is designed to be stateless regarding funds. It coordinates
 * claims by verifying proofs and instructing a separate `AirdropVault` to transfer tokens.
 */
contract MerkleAirdrop is BitmapState, Context {
    /// @notice The immutable Merkle root defining the entire airdrop.
    bytes32 public immutable MERKLEROOT;
    /// @notice The ERC20 token being distributed (for event/logging purposes).
    IERC20 public immutable TOKEN;
    /// @notice The vault contract that holds all tokens for this airdrop.
    IAirdropVault public immutable VAULT;

    /// @notice Emitted when a user successfully claims their tokens.
    event Claimed(uint256 indexed index, address indexed account, uint256 amount);

    /// @notice Reverts if the provided Merkle proof is invalid.
    error InvalidProof();
    /// @notice Reverts if the token transfer fails (forwarded from vault).
    // error TransferFailed(); // Revert will bubble up from the vault.

    /**
     * @param merkleRoot The Merkle root generated by the off-chain script.
     * @param vaultAddress The address of the AirdropVault holding the tokens.
     */
    constructor(bytes32 merkleRoot, address vaultAddress) {
        MERKLEROOT = merkleRoot;
        VAULT = IAirdropVault(vaultAddress);
        TOKEN = VAULT.token();
    }

    /**
     * @notice Main claim function.
     * @param index The claimant's unique index from the Merkle tree.
     * @param amount The claimant's eligible token amount.
     * @param proof The Merkle proof validating the claim.
     */
    function claim(uint256 index, uint256 amount, bytes32[] calldata proof) external {
        // 1. Effects: Mark as claimed (reverts if already true)
        // This is our replay protection.
        _setClaimed(index);

        // 2. Checks: Verify Proof
        // We use _msgSender() for future ERC-2771 (gasless) compatibility.
        address claimer = _msgSender();

        // Reconstruct the leaf hash. Must match the off-chain hashing *exactly*.
        // Standard Pattern: H(H(index, address, amount))
        bytes32 innerHash = keccak256(abi.encode(index, claimer, amount));
        bytes32 leaf = keccak256(abi.encode(innerHash));

        // Use OpenZeppelin's optimized verifier.
        if (!MerkleProof.verifyCalldata(proof, MERKLEROOT, leaf)) {
            revert InvalidProof();
        }

        // 3. Interaction: Instruct Vault to transfer tokens
        emit Claimed(index, claimer, amount);
        // The vault is responsible for an `onlyAirdropContract` check
        // and reverting on failure.
        VAULT.transferTo(claimer, amount);
    }
}
